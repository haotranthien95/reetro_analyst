"""
FastAPI app to upload Excel files and insert rows into PostgreSQL `public.orders`.
- Strict column order (left→right) starting from `ma_dat_hang`.
- `id` auto-generated by DB.
- Optional override by key fields (default: ma_dat_hang,ma_hang).
- Stats API: sum of `thanh_tien` per day-of-month in a date range.
- JWT login (token without expiry) + default admin seeding.
"""
from __future__ import annotations

import pandas as pd
from datetime import datetime, date
from decimal import Decimal, InvalidOperation
from typing import Any, Dict, List, Optional, Sequence

from fastapi import FastAPI, File, Form, HTTPException, Query, UploadFile, Depends
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware

import psycopg
from psycopg.rows import dict_row

from .settings import DATABASE_URL, OVERRIDE_KEY_FIELDS, CORS_ALLOW_ORIGINS
from .auth import ensure_auth_bootstrap, get_current_user, router as auth_router
import calendar
import logging

# ----------------------------------------------------------------------------
# App setup
# ----------------------------------------------------------------------------
app = FastAPI(title="Excel → PostgreSQL (orders)", version="1.1.0")
app.include_router(auth_router, prefix="/auth", tags=["auth"])

app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS_ALLOW_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

pool: Optional[psycopg.Connection] = None


@app.on_event("startup")
def startup() -> None:
    global pool
    try:
        pool = psycopg.connect(DATABASE_URL, autocommit=False, row_factory=dict_row)
    except Exception as e:
        raise RuntimeError(f"Failed to connect to DB: {e}")

    # Bootstrap auth (create extension/table + default admin if needed)
    ensure_auth_bootstrap(pool)


@app.on_event("shutdown")
def shutdown() -> None:
    global pool
    if pool is not None:
        pool.close()

# ----------------------------------------------------------------------------
# Column order & type conversions
# ----------------------------------------------------------------------------
COLUMNS_ORDER: List[str] = [
    "ma_dat_hang", "ma_hoa_don", "ma_van_don", "dia_chi_lay_hang", "thoi_gian", "thoi_gian_tao",
    "ma_khach_hang", "ten_khach_hang", "dien_thoai", "dia_chi_khach_hang", "khu_vuc", "phuong_xa",
    "nguoi_nhan_dat", "kenh_ban", "nguoi_tao", "doi_tac_giao_hang", "nguoi_nhan", "dien_thoai_nguoi_nhan",
    "dia_chi_nguoi_nhan", "khu_vuc_nguoi_nhan", "xa_phuong_nguoi_nhan", "dich_vu", "trong_luong", "dai",
    "rong", "cao", "phi_tra_doi_tac_giao_hang", "ghi_chu", "tong_tien_hang", "giam_gia_phieu_dat",
    "thu_khac", "khach_da_tra", "tien_mat", "the", "chuyen_khoan", "vi", "diem", "don_vi_tinh",
    "thoi_gian_giao_hang", "trang_thai", "ma_hang", "ma_vach", "ten_hang", "thuong_hieu", "ghi_chu_hang_hoa",
    "so_luong", "don_gia", "giam_gia_pham_tram", "giam_gia", "gia_ban", "thanh_tien",
]

INT_COLS = {"trong_luong", "dai", "rong", "cao", "diem", "so_luong"}
DEC_COLS = {
    "phi_tra_doi_tac_giao_hang", "tong_tien_hang", "giam_gia_phieu_dat", "thu_khac", "khach_da_tra", "tien_mat",
    "the", "chuyen_khoan", "vi", "don_gia", "giam_gia_pham_tram", "giam_gia", "gia_ban", "thanh_tien",
}
TS_COLS = {"thoi_gian", "thoi_gian_tao", "thoi_gian_giao_hang"}


def _is_na(v: Any) -> bool:
    return v is None or (isinstance(v, float) and pd.isna(v)) or (isinstance(v, str) and v.strip() == "")


def _to_int(v: Any) -> Optional[int]:
    if _is_na(v):
        return None
    try:
        if isinstance(v, float):
            return int(v)
        if isinstance(v, str):
            v = v.replace(",", "").strip()
            if v == "":
                return None
            return int(float(v))
        return int(v)
    except Exception:
        return None


def _to_dec(v: Any) -> Optional[Decimal]:
    if _is_na(v):
        return None
    try:
        if isinstance(v, Decimal):
            return v
        if isinstance(v, (int, float)):
            return Decimal(str(v))
        if isinstance(v, str):
            cleaned = v.replace(" ", "").replace(",", "")
            return Decimal(cleaned)
    except (InvalidOperation, ValueError):
        return None
    return None


def _to_ts(v: Any) -> Optional[datetime]:
    if _is_na(v):
        return None
    try:
        ts = pd.to_datetime(v, errors="coerce", dayfirst=True)
        if pd.isna(ts):
            return None
        if isinstance(ts, pd.Timestamp):
            return ts.to_pydatetime().replace(tzinfo=None)
        return None
    except Exception:
        return None


def _to_text(v: Any) -> Optional[str]:
    if _is_na(v):
        return None
    s = str(v).strip()
    return s if s != "" else None


def convert_row(raw: Sequence[Any]) -> Dict[str, Any]:
    data = list(raw[: len(COLUMNS_ORDER)]) + [None] * max(0, len(COLUMNS_ORDER) - len(raw))
    row_dict: Dict[str, Any] = {}
    for col, v in zip(COLUMNS_ORDER, data):
        if col in INT_COLS:
            row_dict[col] = _to_int(v)
        elif col in DEC_COLS:
            row_dict[col] = _to_dec(v)
        elif col in TS_COLS:
            row_dict[col] = _to_ts(v)
        else:
            row_dict[col] = _to_text(v)
    return row_dict


def build_where_clause(key_fields: List[str]) -> str:
    if not key_fields:
        raise ValueError("OVERRIDE_KEY_FIELDS must not be empty")
    return " AND ".join([f"{f} = %({f})s" for f in key_fields])


INSERT_SQL = f"""
INSERT INTO public.orders (
    {', '.join(COLUMNS_ORDER)}
) VALUES (
    {', '.join([f'%({c})s' for c in COLUMNS_ORDER])}
)
"""

# ----------------------------------------------------------------------------
# Routes
# ----------------------------------------------------------------------------
@app.get("/", response_class=HTMLResponse)
async def upload_form() -> str:
    key_fields = ", ".join(OVERRIDE_KEY_FIELDS)
    return f"""
    <html>
      <head><title>Upload Excel to orders</title></head>
      <body>
        <h2>Upload Excel (.xlsx) → public.orders</h2>
        <p><b>Column mapping:</b> Strict by position starting from <code>ma_dat_hang</code> to <code>thanh_tien</code>. No headers are read.</p>
        <p><b>Override key fields:</b> {key_fields}</p>
        <p><b>Auth:</b> Use <code>POST /auth/login</code> to obtain a Bearer token, then set <code>Authorization: Bearer &lt;token&gt;</code> for protected endpoints.</p>
        <form action="/upload-excel" method="post" enctype="multipart/form-data">
          <input type="file" name="file" accept=".xlsx" required />
          <label style="margin-left:12px;">
            <input type="checkbox" name="override" value="true" /> Override existing rows (by key fields)
          </label>
          <button type="submit">Upload</button>
        </form>
      </body>
    </html>
    """

@app.post("/upload-excel")
async def upload_excel(
    file: UploadFile = File(...),
    override: Optional[str] = Form(None),
):
    if not file.filename.lower().endswith(".xlsx"):
        raise HTTPException(status_code=400, detail="Please upload a .xlsx Excel file")

    try:
        df = pd.read_excel(file.file, header=None, engine="openpyxl")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to read Excel: {e}")

    df = df.dropna(how="all")
    if df.empty:
        return JSONResponse({"rows_processed": 0, "inserted": 0})

    rows = df.values.tolist()
    rows_processed = inserted = 0

    if pool is None:
        raise HTTPException(status_code=500, detail="DB pool not initialized")

    with pool.cursor() as cur:
        try:
            for raw in rows:
                rows_processed += 1
                data = convert_row(raw)

                if not data.get("ma_dat_hang"):
                    continue

                cur.execute(INSERT_SQL, data)
                inserted += 1
            pool.commit()
        except Exception as e:
            pool.rollback()
            raise HTTPException(status_code=500, detail=f"DB error: {e}")

    return JSONResponse({
        "rows_processed": rows_processed,
        "inserted": inserted,
    })


@app.get("/api/stats/daily")
async def stats_daily(
    start: date = Query(..., description="YYYY-MM-DD"),
    end: date = Query(..., description="YYYY-MM-DD"),
    user: dict = Depends(get_current_user),
):
    if end < start:
        raise HTTPException(status_code=400, detail="end must be >= start")
    if pool is None:
        raise HTTPException(status_code=500, detail="DB pool not initialized")

    sql = """
        SELECT EXTRACT(DAY FROM thoi_gian)::int AS ngay_trong_thang,
               COALESCE(SUM(thanh_tien), 0)::text AS tong_gia_tri
        FROM public.orders
        WHERE thoi_gian >= %s AND thoi_gian < %s + INTERVAL '1 day'
        GROUP BY 1
        ORDER BY 1
    """

    with pool.cursor() as cur:
        cur.execute(sql, (datetime.combine(start, datetime.min.time()), datetime.combine(end, datetime.min.time())))
        rows = cur.fetchall()

    out = [
        {
            "ngay_trong_thang": r["ngay_trong_thang"],
            "tong_gia_tri": int(Decimal(r["tong_gia_tri"])) if r["tong_gia_tri"] is not None else 0,
        }
        for r in rows
    ]
    return out

@app.get("/api/stats/total-monthly")
async def stats_total_monthly(
    user: dict = Depends(get_current_user),
):
    if pool is None:
        raise HTTPException(status_code=500, detail="DB pool not initialized")

    today = datetime.today()
    first_day_this_month = datetime.combine(today.replace(day=1), datetime.min.time())
    first_day_last_month = datetime.combine(
        (first_day_this_month.replace(day=1) - pd.DateOffset(months=1)).date(),
        datetime.min.time()
    )
    last_day_last_month = datetime.combine(
        (first_day_this_month - pd.DateOffset(days=1)).date(),
        datetime.min.time()
    ).replace(hour=23, minute=59, second=59, microsecond=0)
    last_day_this_month = (first_day_this_month + pd.DateOffset(months=1) - pd.DateOffset(days=1)).to_pydatetime().replace(hour=23, minute=59, second=59)

    sql = """
        SELECT
            SUM(CASE WHEN thoi_gian >= %(start_this_month)s AND thoi_gian < %(start_next_month)s THEN thanh_tien ELSE 0 END) AS total_this_month,
            SUM(CASE WHEN thoi_gian >= %(start_last_month)s AND thoi_gian <= %(end_last_month)s THEN thanh_tien ELSE 0 END) AS total_last_month
        FROM public.orders
    """
    params = {
        "start_this_month": first_day_this_month,
        "start_next_month": (first_day_this_month + pd.DateOffset(months=1)).to_pydatetime(),
        "start_last_month": first_day_last_month,
        "end_last_month": last_day_last_month,
    }

    with pool.cursor() as cur:
        cur.execute(sql, params)
        row = cur.fetchone()

    return {
        "this_month": int(row["total_this_month"] or 0),
        "last_month": int(row["total_last_month"] or 0),
    }

@app.get("/api/stats/partial-monthly")
async def stats_partial_monthly(
    today: date = Query(..., description="YYYY-MM-DD"),
    user: dict = Depends(get_current_user),
):
    if pool is None:
        raise HTTPException(status_code=500, detail="DB pool not initialized")

    first_day_this_month = datetime.combine(today.replace(day=1), datetime.min.time())
    last_day_this_month = datetime.combine(today, datetime.max.time()).replace(microsecond=0)

    # Calculate same day last month
    if today.month == 1:
        last_month_year = today.year - 1
        last_month = 12
    else:
        last_month_year = today.year
        last_month = today.month - 1

    try:
        last_month_day = datetime.combine(datetime(
            last_month_year, last_month, today.day),datetime.max.time()).replace(microsecond=0)
    except ValueError:
        # If last month doesn't have this day (e.g. Feb 30), use last day of last month
        last_day = calendar.monthrange(last_month_year, last_month)[1]
        last_month_day = datetime.combine(datetime(last_month_year, last_month, last_day), datetime.max.time()).replace(microsecond=0)

    first_day_last_month = datetime(last_month_year, last_month, 1, 0, 0, 0)

    sql = """
        SELECT
            SUM(CASE WHEN thoi_gian >= %(start_this_month)s AND thoi_gian <= %(end_this_month)s THEN thanh_tien ELSE 0 END) AS total_this_month,
            SUM(CASE WHEN thoi_gian >= %(start_last_month)s AND thoi_gian <= %(end_last_month)s THEN thanh_tien ELSE 0 END) AS total_last_month
        FROM public.orders
    """
    params = {
        "start_this_month": first_day_this_month,
        "end_this_month": last_day_this_month,
        "start_last_month": first_day_last_month,
        "end_last_month": last_month_day,
    }
    print(f"Partial monthly stats params: {params}")

    with pool.cursor() as cur:
        cur.execute(sql, params)
        row = cur.fetchone()

    return {
        "totalThisMonth": int(row["total_this_month"] or 0),
        "totalLastMonth": int(row["total_last_month"] or 0),
    }

@app.get("/healthz")
async def healthz():
    if pool is None:
        raise HTTPException(status_code=500, detail="DB pool not initialized")
    try:
        with pool.cursor() as cur:
            cur.execute("SELECT 1")
            cur.fetchone()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB error: {e}")
    return {"ok": True}